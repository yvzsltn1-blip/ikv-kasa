rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Admin check: hardcoded email or metadata/admins list
    function isAdmin() {
      return request.auth != null && (
        request.auth.token.email == 'yvzsltn61@gmail.com' ||
        (
          exists(/databases/$(database)/documents/metadata/admins) &&
          request.auth.token.email in get(/databases/$(database)/documents/metadata/admins).data.emails
        )
      );
    }

    function isAdminEmail(email) {
      return email is string && (
        email == 'yvzsltn61@gmail.com' ||
        (
          exists(/databases/$(database)/documents/metadata/admins) &&
          email in get(/databases/$(database)/documents/metadata/admins).data.emails
        )
      );
    }

    function isBlockedUserByUid(uid) {
      return uid is string &&
        exists(/databases/$(database)/documents/users/$(uid)) &&
        ('blockInfo' in get(/databases/$(database)/documents/users/$(uid)).data) &&
        (get(/databases/$(database)/documents/users/$(uid)).data.blockInfo.isBlocked == true);
    }

    function isCurrentUserBlocked() {
      return request.auth != null && isBlockedUserByUid(request.auth.uid);
    }

    function isApprovedUserByUid(uid) {
      return uid is string && (
        !exists(/databases/$(database)/documents/users/$(uid)) ||
        !('accessStatus' in get(/databases/$(database)/documents/users/$(uid)).data) ||
        get(/databases/$(database)/documents/users/$(uid)).data.accessStatus == 'approved'
      );
    }

    function isCurrentUserApproved() {
      return request.auth != null && isApprovedUserByUid(request.auth.uid);
    }

    function canDataEntry() {
      return request.auth != null &&
        isCurrentUserApproved() &&
        !isCurrentUserBlocked() && (
        !exists(/databases/$(database)/documents/users/$(request.auth.uid)) ||
        !('permissions' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data) ||
        !('canDataEntry' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.permissions) ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.permissions.canDataEntry == true
      );
    }

    function canGlobalSearch() {
      return request.auth != null &&
        isCurrentUserApproved() &&
        !isCurrentUserBlocked() && (
        !exists(/databases/$(database)/documents/users/$(request.auth.uid)) ||
        !('permissions' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data) ||
        !('canGlobalSearch' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data.permissions) ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.permissions.canGlobalSearch == true
      );
    }

    function isSelfAutoApproveSlotDecrement() {
      return request.auth != null &&
        !isAdmin() &&
        resource != null &&
        request.resource.data.diff(resource.data).changedKeys().hasOnly(['autoApproveSlots', 'updatedAt']) &&
        resource.data.autoApproveSlots is number &&
        request.resource.data.autoApproveSlots is number &&
        resource.data.autoApproveSlots > 0 &&
        request.resource.data.autoApproveSlots == resource.data.autoApproveSlots - 1 &&
        !exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        existsAfter(/databases/$(database)/documents/users/$(request.auth.uid)) &&
        getAfter(/databases/$(database)/documents/users/$(request.auth.uid)).data.accessStatus == 'approved';
    }

    function isDirectMessagingEnabled() {
      return !exists(/databases/$(database)/documents/metadata/messageSettings) ||
        get(/databases/$(database)/documents/metadata/messageSettings).data.directMessagesEnabled != false;
    }

    function userPermissionsUnchanged() {
      return request.resource.data.diff(resource.data).changedKeys().hasAny(['permissions']) == false;
    }

    function isSearchQuotaOnlyUpdate() {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(['searchQuota']);
    }

    function isMessageQuotaOnlyUpdate() {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(['messageQuota']);
    }

    function receiverAcceptsMessage(receiverId) {
      return !exists(/databases/$(database)/documents/messagePrefs/$(receiverId)) ||
        get(/databases/$(database)/documents/messagePrefs/$(receiverId)).data.receiveOnlyFromAdmin != true ||
        isAdmin();
    }

    function ownerUsernameWriteAllowed() {
      return !('username' in resource.data) ||
        (
          ('username' in request.resource.data) &&
          request.resource.data.username == resource.data.username
        );
    }

    // Users: owner can read; writes are controlled by permission flags
    match /users/{userId} {
      allow read: if request.auth != null && (request.auth.uid == userId || isAdmin());
      allow create: if request.auth != null && (request.auth.uid == userId || isAdmin());
      allow update: if request.auth != null && (
        isAdmin() ||
        (
          request.auth.uid == userId &&
          userPermissionsUnchanged() &&
          ownerUsernameWriteAllowed() &&
          (canDataEntry() || isSearchQuotaOnlyUpdate() || isMessageQuotaOnlyUpdate())
        )
      );
      allow delete: if request.auth != null && (request.auth.uid == userId || isAdmin());
    }

    // Username reservation
    match /usernames/{username} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && (
        isAdmin() ||
        (
          request.resource.data.uid == request.auth.uid &&
          (
            !exists(/databases/$(database)/documents/users/$(request.auth.uid)) ||
            !('username' in get(/databases/$(database)/documents/users/$(request.auth.uid)).data)
          )
        )
      );
      allow update: if false;
      allow delete: if isAdmin();
    }

    // Public profile index for messaging search
    match /publicProfiles/{userId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null &&
        (request.auth.uid == userId || isAdmin()) &&
        request.resource.data.uid is string &&
        request.resource.data.uid == userId &&
        request.resource.data.username is string &&
        request.resource.data.username.size() <= 100 &&
        request.resource.data.emailLower is string &&
        request.resource.data.emailLower.size() <= 200;
      allow delete: if request.auth != null && (request.auth.uid == userId || isAdmin());
    }

    // Global item sharing (field size limits to prevent DB bloat)
    match /globalItems/{itemId} {
      allow read: if request.auth != null && (isAdmin() || canGlobalSearch());
      allow create, update: if request.auth != null &&
        request.resource.data.uid == request.auth.uid &&
        canDataEntry() &&
        request.resource.data.username is string &&
        request.resource.data.username.size() <= 100 &&
        request.resource.data.accountName is string &&
        request.resource.data.accountName.size() <= 100 &&
        request.resource.data.serverName is string &&
        request.resource.data.serverName.size() <= 100 &&
        request.resource.data.charName is string &&
        request.resource.data.charName.size() <= 100 &&
        request.resource.data.containerName is string &&
        request.resource.data.containerName.size() <= 50 &&
        (!('socialLink' in request.resource.data) || !request.resource.data.socialLink.matches('.+') || request.resource.data.socialLink.size() <= 500);
      allow delete: if request.auth != null && (isAdmin() || (resource.data.uid == request.auth.uid && canDataEntry()));
    }

    // Global enchantment suggestions
    match /metadata/enchantments {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global potion suggestions
    match /metadata/potions {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global mine suggestions (name + level)
    match /metadata/mines {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global "other" suggestions (name + level)
    match /metadata/others {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global glasses suggestions (name + level)
    match /metadata/glasses {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global talisman suggestions
    match /metadata/talismans {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Global weapon type suggestions
    match /metadata/weapons {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Admin list
    match /metadata/admins {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Search limits
    match /metadata/searchLimits {
      allow read: if request.auth != null;
      allow write: if isAdmin() || isSelfAutoApproveSlotDecrement();
    }

    // Messaging system settings
    match /metadata/messageSettings {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Message preferences (user-controlled)
    match /messagePrefs/{userId} {
      allow read: if request.auth != null;
      allow create, update, delete: if request.auth != null && (request.auth.uid == userId || isAdmin());
    }

    // Direct messages between users
    match /messages/{messageId} {
      allow read: if request.auth != null && (
        isAdmin() ||
        (
          isCurrentUserApproved() &&
          !isCurrentUserBlocked() &&
          request.auth.uid in resource.data.participants
        )
      );
      allow create: if request.auth != null &&
        request.resource.data.senderUid == request.auth.uid &&
        request.resource.data.receiverUid is string &&
        request.resource.data.conversationId is string &&
        request.resource.data.conversationId.size() <= 200 &&
        request.resource.data.text is string &&
        request.resource.data.text.size() >= 1 &&
        request.resource.data.text.size() <= 1500 &&
        request.resource.data.createdAt is number &&
        request.resource.data.participants is list &&
        request.resource.data.participants.size() == 2 &&
        request.resource.data.readBy is list &&
        request.resource.data.readBy.size() <= 2 &&
        request.auth.uid in request.resource.data.readBy &&
        request.auth.uid in request.resource.data.participants &&
        request.resource.data.receiverUid in request.resource.data.participants &&
        request.resource.data.keys().hasOnly(['conversationId', 'participants', 'senderUid', 'receiverUid', 'senderDisplay', 'receiverDisplay', 'text', 'createdAt', 'readBy']) &&
        (isAdmin() || (isCurrentUserApproved() && !isCurrentUserBlocked() && isDirectMessagingEnabled())) &&
        receiverAcceptsMessage(request.resource.data.receiverUid);
      allow update: if request.auth != null && (
        isAdmin() ||
        (
          isCurrentUserApproved() &&
          !isCurrentUserBlocked() &&
          request.auth.uid == resource.data.receiverUid &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['readBy', 'readAt']) &&
          request.resource.data.readBy is list &&
          request.auth.uid in request.resource.data.readBy &&
          request.resource.data.senderUid == resource.data.senderUid &&
          request.resource.data.receiverUid == resource.data.receiverUid &&
          request.resource.data.conversationId == resource.data.conversationId &&
          request.resource.data.participants == resource.data.participants &&
          request.resource.data.text == resource.data.text &&
          request.resource.data.createdAt == resource.data.createdAt
        ) ||
        (
          isCurrentUserApproved() &&
          !isCurrentUserBlocked() &&
          request.auth.uid in resource.data.participants &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['deletedFor']) &&
          request.resource.data.deletedFor is list &&
          request.resource.data.deletedFor.hasAll(
            ('deletedFor' in resource.data && resource.data.deletedFor is list)
              ? resource.data.deletedFor
              : []
          ) &&
          request.auth.uid in request.resource.data.deletedFor
        )
      );
      allow delete: if request.auth != null && (
        isAdmin() ||
        (isCurrentUserApproved() && !isCurrentUserBlocked() && request.auth.uid in resource.data.participants)
      );
    }

    // Notifications routed to admin users (blocked-account contact templates)
    match /adminNotifications/{notificationId} {
      allow read: if request.auth != null && (
        isAdmin() ||
        request.auth.token.email == resource.data.recipientEmail ||
        request.auth.uid == resource.data.senderUid
      );
      allow create: if request.auth != null && (
        isAdmin() ||
        (
          isCurrentUserBlocked() &&
          request.resource.data.type == 'blocked_contact' &&
          request.resource.data.senderUid == request.auth.uid &&
          request.resource.data.recipientEmail is string &&
          isAdminEmail(request.resource.data.recipientEmail) &&
          request.resource.data.templateId is string &&
          request.resource.data.templateId.size() <= 100 &&
          request.resource.data.templateLabel is string &&
          request.resource.data.templateLabel.size() <= 200 &&
          request.resource.data.templateMessage is string &&
          request.resource.data.templateMessage.size() <= 2000 &&
          request.resource.data.createdAt is number &&
          request.resource.data.read == false &&
          request.resource.data.keys().hasOnly(['type', 'senderUid', 'recipientEmail', 'templateId', 'templateLabel', 'templateMessage', 'createdAt', 'read'])
        )
      );
      allow update: if request.auth != null && (
        isAdmin() ||
        (
          request.auth.token.email == resource.data.recipientEmail &&
          request.resource.data.diff(resource.data).changedKeys().hasOnly(['read', 'readAt']) &&
          request.resource.data.read == true &&
          request.resource.data.readAt is number
        )
      );
      allow delete: if isAdmin();
    }

    // Deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
